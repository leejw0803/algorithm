# 문제 설명
- 두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 
- 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.

1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.
2. words에 있는 단어로만 변환할 수 있습니다.

- 예를 들어 begin이 "hit", target가 "cog", words가 ["hot","dot","dog","lot","log","cog"]라면 "hit" -> "hot" -> "dot" -> "dog" -> "cog"와 같이 4단계를 거쳐 변환할 수 있습니다.

- 두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.

# 문제 분석
1. 그래프 형태를 만든다.
    두 글자가 같은 단어들끼리 묶는다. 
    배열로 나타낼 수 있다. 각 문자열의 (index+2)가 해당 노드의 번호이고, 1번 노드는 begin,
        이 때, target이 words 안에 없다면 0을 반환한다.
2. 1번 노드부터 target 노드까지의 최단 경로 
    BFS를 통해서 탐색할 수 있다.
    방문 노드를 튜플 형태(<노드번호>, <노드까지의 경로>)로 bfs_list에 담으면서 큐가 빌 때까지 반복한다.
        큐가 비었을 때 bfs_list에 target 노드의 번호가 있다면 그 노드의 경로가 답
        list에 target 노드의 번호가 없다면 0


# from collections import deque
- bfs를 사용할 때에는 queue(선입선출)를 사용해야 되고, 일반 list의 insert같은 경우 O(n)만큼의 시간 복잡도를 가진다
- 따라서 deque를 제공하면 성능향상에 도움을 줄 수 있다.

# index 접근
- python은 문자열, 리스트, 튜플 모두 인덱스로 접근이 가능하다.

# 비구조화 할당
- 이렇게 부르는 지는 모르겠으나, JS의 비구조화 할당과 같은 문법이 제대로 작동한다.

# 문제를 잘 읽어야 한다.
- 문제에서 제시하는 제한사항들 중 메모리나 성능과 관련된 정보가 아닌 문제의 맞고 틀림과 직접적으로 연관되는 사항들이 존재한다.
- 반드시 제한사항을 읽고 이에 해당하는 구현을 하도록 하자.
- 더불어 bfs, dfs의 핵심은 graph를 만들어내는 것이다