# 문제 설명
- 무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.
- 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.
- 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.
- 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

## 제한사항
> 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.
> 각 사람의 몸무게는 40kg 이상 240kg 이하입니다.
> 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.
> 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.

# 문제 분석
- 구명 보트를 최대한 작게 사용하여 모든 사람을 구출하고자 함.
- 몸무게 배열 people, 무게 제한 limit 
- 구명보트 갯수의 최솟값 
- 앞에서 부터 넣어서 100이 넘기 전에 보낸다.
- 각 요소에 대해 비교한다...?
- 아냐 한번에 가장 작은 놈들을 넣어야 해
- 가장 작은 애들부터 몰아서 넣어야 한다 이게 최솟값이 됨 -> 반례 30 49 51 60 61 70 / 100 
- 합이 정확히 limit이 되는 경우로 쪼개야 한다.
- 다시 2명 밖에 타지 못한다.
- 합이 100이 되는 것부터 차례대로 제거

# 첫 번째 시도 === Lifeboat_myself.js
- 합이 100이 되는 것부터 먼저 제거 하기 위해서 처음 놈을 꺼내고
- 꺼낸 놈하고의 합이 100이하인 것중에서 가장 큰 놈을 골라 뺀다.
- 없다면 처음에 고른놈만 뺀다.
- 이 방식으로 하면 답은 모두 맞지만, 효율성이 떨어진다. => 반복문 안에 반복함수가 너무 많다. sort, filter, splice, indexOf => 효율성에서 오류가 난다면 무조건 반복문을 줄이는 방향으로 고민해보자.
- 여기서 insight를 얻을 것은, sort() 함수는 당연히 오름차순이 아니라는 점! 확실하게 하기 위해서 오름차순을 원한다면 콜백함수를 지정해 주자.

# 두 번째 === Lifeboat.js
- 맞은 답. 
- 내림차순으로 정렬하고 큰 놈부터 챙긴다.
- 마지막 놈이 제일 작으니까 마지막 놈과의 합이 limit이하라면 둘 다 내보낸다.
- 아니라면 앞에놈만 내보낸다.
