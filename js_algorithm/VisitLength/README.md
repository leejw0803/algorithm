# 문제 설명

- 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)

- 단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.

# 문제 분석

- 게임캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 함
- 움직인 길이는 9이지만 처음 걸어본 길의 길이는 7이 된다.
- u l r d 가 한 세트로 나오면 제자리로 돌아오게 된다.
- 제자리로 돌아오는 경우 - 겹치는 경우 : u-d, l-r, 이렇게 연속된 경우 혹은 u l r d 4개가 한번에 나오는 경우
- 이렇게 접근하면 문자열만 가지고 풀 수 있을 것 같지만 굉장히 힘들다
- 그냥 현재 위치에서 다음 위치를 표시해 보자
- 입출력 예 1번에서 주어진 대로 표현하면 ULURRDLLU
- [0,0] [0,1] [-1,1] [-1,2] [0,2] [1,2] [1,1] / [0,1] [-1,1] [-1,2]
- 전체 있었던 위치들에서 겹치는 것만 빼면이 아니야 시발
- 겹치는 것만 빼는 게 아니라 겹치는 배열을 빼야해 -> 패턴 구하기 쉽지 않을 듯 하다.
- 그리고 이렇게 구하면 딱히 위에서 말한 패턴에 대해 달라지는 것도 없다.
- 현재 포지션에서 다음 포지션으로 가는 것이 전에도 있었던 길이면 카운트 하지 않는다.
- 그럼 현재 포지션에서 다음 포지션으로 가는 길 : 이게 하나의 요소
- 현재 포지션 , 방향 키, 다음 포지션 <- 이걸 하나로 저장
- 질문하기 및 object array에서 find가 먹지 않는다는 것을 알고 길을 바꿈
- 중복 제거를 쉽게 하기 위해 한 요소를 전 포지션 이후 포지션 이렇게 4개의 숫자를 가진 배열로 구성
- 배열이 중복되면 제거, 같은 곳으로 이동하면 제거 => 8번부터 다 틀림
- 다시 질문하기를 보고 출발위치와 도착위치가 반대가 되어도 같은 길이라는 것을 알게 됨
- 따라서 배열이 서로 같다는 것에 대한 로직을 변경 => 일일이 넣어주도록
- 해결

# 깊은 복사

- 이것 때문에 꽤 많은 시간을 날렸다.
- JavaScript에서는 그냥 할당이나 파라미터 넘겨주는 것들이 전부 깊은 복사라고 생각하면 된다. 즉 할당하고 이전 값을 변경해도 할당한 값에 반영된다. ㅅㅂ
- object를 얕게 복사하려 할 때에는 obj.slice(0) 을 넘겨주면 얇은 복사가 가능하다.

# object array의 중복제거 및 equal 로직

- 방법이 없다. 그냥 구현해라
- 구현은 짱구를 좀만 굴리면 구현이 가능하다. 보통은 이중 for문으로 해결 가능할 듯 하다.

# concat

- 이거 꽤나 헷갈리는데 concat하게 되면 원래 있던 배열에 바로 붙는 게 아니라 붙은 배열을 반환한다. r-value
- 따라서 어딘가 할당해줘야 써먹을 수 있음. 아니면 바로 parameter로 넘겨주거나.
