# 문제 설명
- 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
- 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.
- 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

## 제한 사항
> number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
> k는 1 이상 number의 자릿수 미만인 자연수입니다.

# 문제 분석
어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 함.
제거할 수의 갯수 k
  
1. number를 배열로 바꾼다.
2. 배열로 바꾼 number에서 k개의 수를 제거했을 때 만들 수 있는 가장 큰 숫자에 대한 고려
> 2-1. 앞에서 부터 가장 큰 숫자를 남긴다.
> 2-2. 인덱스의 범위는 i=0에서부터 i<num.length-k
> 2-3. 가장 큰 수를 기준으로 나눠서 뒷 배열을 새로운 배열로 취급, k--;

# 첫 번째 방법
- 위에 분석한 대로 풀려고 했으나 효율성에서 문제가 생겼다.
- 반복문이 많아져 실행시간이 너무 오래걸림

# 문제 재분석
- 여러 검색매체를 찾아본 결과 스택을 이용하여 해결
- number를 처음부터 순회하면서 값을 무조건 stack에 넣는다.
- 만약 number 배열에서 다음 index의 number가 전 index의 number보다 작다면 (result[result.length-1] < cur)
- 작지 않을 때까지 배열에 있는 것을 제거하고 그만큼 k--;
- 이렇게 될 경우 순서를 해치지 않고 가장 앞에 가장 큰수만 남게 된다.
- 만약 배열을 전부 순회했을 때 k가 남아있다면 뒤에서 부터 k만큼을 제거한다. -> 앞에서 작은 수들은 제거되었고 뒤에 남은 수들이 작은 수이기 때문.. :  이부분은 조금 이해하기 어렵다.

# typo 문제
- programmers에서는 length의 오류를 감지하지 못하고, 논리오류로 컴파일 오류가 나지 않는다.
- legnth라고 쓰고 한참을 헤맸습니다....
- 오타가 없는지를 확실하게 확인하고 진행하도록 하자.

# Greedy에 대한 문제
- 솔직히 말해서 greedy를 딱 이건 탐욕법이야! 하고 풀 수 있을 것 같지 않다.
- 문제를 풀 때, 만약 효율문제가 난다면 stack을 이용해 접근해 보겠다는 생각을 해보는 것도 좋은 것 같다.
- 효율 문제가 났을 때에는 뒤도 돌아보지 말고 엎은다음에 다시 생각하자. 