# 문제 설명

- 짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

# 문제 분석

- 알파벳 소문자로 이루어진 문자열을 가지고 시작
- 먼저 문자열에서 같은 알파벳이 2개 붙어있는 짝을 찾는다.
- 그 둘을 제거한뒤 앞뒤로 문자열을 이어 붙인다.
- 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료
- 성공적으로 수행할 수 있는지를 반환하는 함수
- 성공이면 1 아니면 0을 리턴하도록

## 첫 번째 접근

> 1. i는 0부터 arr.length-2까지 <- for가 아닌 while로 풀자
> 2. arr[i]와 arr[i+1]이 같은 경우 둘 다 제거 arr.splice(i, 2);
> 3. 그리고 break;
> 4. 그리고 다시 처음부터 체크하기

- 결과적으로 효율성 측면에서 많이 떨어졌다. splice에 순회가 있기 때문에 O(n\*n) 만큼 잡아먹는 듯 하다

## 두 번째 접근

- 가능한지 불가능한지의 여부만 체크하면 된다.
- 가능한 경우는 어떤 경우인가
- 가운데에 2의 배수로 연속된 문자열이 있는 경우
- 일단 한 번 쭉 돌면서 해당 문자열에서 문자의 종류별로 몇 개의 문자가 존재하는 지 체크
- 만약 2의 배수개가 존재하지 않는다면 0
- 2의 배수개가 존재할 경우
- 같은 문자의 인덱스 차이가 2의 배수가 아닐 경우 0
- 이걸 정확히 하기 위해서는 문자종류에 따른 인덱스의 나열이 있으면 될 듯 하다. 일단 이것부터 구해보자
- reduce를 사용해서 구했으나 정확한 해결책을 찾지 못해 패스

## 마지막 접근

- 첫수 부터 스택에 넣는다.
- 스택에 같은 문자가 2번 쌓이면 제거한다.

> 1. stack[stack.length-1] === arr.shift() => stack.pop();
> 2. else stack.push(arr.shift());
> 3. arr.length === 0 일 때, stack.length !== 0 이면 0 stack.length === 0 이면 1

# js에서 pop과 shift

- shift, unshift는 push와 pop보다 느림
- 그 이유는 push와 pop은 배열의 제일 뒤에 데이터를 추가하기만 하면 되지만
- shift와 unshift는 배열의 첫번째부터 들어가기때문에 그 뒤의 item들을 하나하나 밀어내거나, 다시 당겨와야되기에 처리과정이 오래걸림
- 이러한 처리과정은 배열의 길이가 길수록 처리시간이 더 오래걸림
- 출처 : https://velog.io/@younuk23/TIL20200717Javascript-%EB%B0%B0%EC%97%B4-JSON-%EB%B9%84%EB%8F%99%EA%B8%B0
